+ 遗传算法解决tsp问题
    + 业务流程
        + 用户在jsp页面输入需要遍历的地点，点击提交到servlet
        + servlet在接收到地点个数之后，组成n*n的二维数据，每个数组单位中的值代表两个地区之间实际的公路距离，之后通过地图api先对地点进行经纬度转换然后得出两地公路距离，填充进二维数组，作为数据源
        + 当数据源获取完毕之后，开始进行遗传算法
        + 遗传算法的迭代过程事实上是一个围绕适应度进行迭代的过程，每一次迭代包含继承，交换，变异三个过程
            + 在我的项目中，每一条染色体的适应度是该染色体代表路程到倒数乘以20000（20000是让这个适应度能够被表示出来，因为数据太小，只取倒数，程序好像无法比较）
            + 项目中对于继承的实现体现是每次迭代中适应度前百分之二十的染色体将会被继承到下一次迭代
            + 交换过程即两条染色体进行片段交换，因为地点序号具有唯一性，直接交换会产生重复，所以我做了一定操作
                + 通过轮盘赌算法选取两个将要进行交换的染色体，染色体1不变，染色体2截取交换片段，需要交换的片段被保存到染色体3中
                + 对染色体1和染色体3进行匹配，只保留与染色体3中不重复的序号，生成染色体4
                + 将染色体4逆序插入染色体3中，完成基因片段的交换
            + 变异
                + 随机交换一条染色体的两个基因随机交换
        + 经过一定的迭代次数后，遗传算法结束并返回适应度最高的染色体，及我们需要的路线，这条染色体将会返回给jsp，在前端页面构建符合静态图api需求格式的url，并呈现出最后结果
    + 分为两部分
        + servlet部分装载算法
            + 地图接口类
                + 经纬度解析接口
                + 不同维度之间公路距离接口
                + 静态图接口
            + 遗传算法
                + 染色体类
                + 函数执行类
            + servlet启动类
        + jsp部分呈现页面
    + 问题
        + 这是最开始的实践项目，一开始老师只是让我们处理一下旅行商问题，学长那边定计划是用遗传算法处理，编程语言用java，于是花了两天过了一遍java基础语法，然后csdn找了一个遗传算法实现开始啃，最后保留了方法框架将内容根据我的目标修改了，但是那时基础很不牢固，几乎就是for循环加面向百度和Stack Overflow的编程，代码很丑陋，前一天复盘时自己都不想看下去了，还好当时写了注释。
    + 收获
        + 第一次实际接触工程，一开始什么都不懂，完全没有进展，改代码都不知道怎么改，后来帮别人找bug的过程中突然意识到输出才是调试程序的最好方式，这种方式一直被沿用到最近的一个项目，体会更加明显。接口的调用十分繁琐，我在想为什么接口返回的json数据明明是结构化的，却只能用截断字符段这种方式提取信息呢？后来才知道现在的接口是给前端调用的，还有就是java，html，js混杂的开发模式，让我很不舒服，学习到了一些入门的方法，也积累了很多问题，不过这些问题在随着web技术的深入学习一个个的被解决了
+ 运满满app的模仿
    + 业务流程
        + 用户注册
        + 用户手机号认证（我的--myhome页面），订单是根据用户的电话来进行筛选的，所以在执行操作前必须先进行认证，填入手机号后点击上方未认证就可以完成认证
        + 货主端在发货页（对应item-page.vue处代码），点击发货按钮，填入相应字段，前端将会将这些字段包含用户名，用户号码发送至后端处理
        + 订单生成后的状态为1会在司机端的当天货源中显示，点击橙色图标订单状态会进行更改，变为状态2待确定状态
        + 货主端在订单-未确认处点击橙色图标完成订单状态更改为运输中
        + 司机端运输完成后再订单-运输中进行更改，订单状态改为未支付
        + 货主端支付完成订单状态改为未评价，评价点击完成后流程结束
    + 项目结构
        + 前端
            + vue框架
            + vuex配合localstorage进行用户管理（localstorage是永久储存，sessionstorage当会话结束之后会被清除）
                + state（定义用户数据）
                + mutations（修改state中的数据）
                + getters（获取state中的数据）
            + css
                + 移动端单位转换为rem
                + flex布局
                + position
                + margin padding
                + 阿里云iconfont
            + es6语法
            + better-scroll使用
        + 后端
            + bean
                + user
                + order
                + result
            + controller
                + ordercontroller
                + usercontroller
            + service
                + userservice
                + orderservice
            + mapper
                + usermapper
                + ordermapper
    + 问题
        + 只是单纯的使用了框架和组件，几乎没有做细节处理，前端请求接口数据方式很单调，几乎全部使用post方式，没有对于数据做任何判断，而后端接口风格没有遵循restful风格，甚至没有写post之外的其他方法，业务逻辑十分简陋，前端对于js的使用较少，因为是赶进度的速成品，几乎没什么亮点
        + 这个项目本意是模仿运满满的app但是用户管理存在问题，尤其是app是没有localstorage功能的，封装成apk之后，目前使用的vuex将会失效
    + 收获
        + 逐渐开始了解前后端交互的方式，虽然这个项目很粗糙，也有很多不足，不过因为几乎是突击的前后端内容，能呈现出这个结果个人已经比较满意了，也为后面的项目打好了一定的基础，并且前后端分离架构比起jsp代码简洁了很多，虽然mvvm模式比起mvc模式来说需要多写一些数据传输方法，但是比起代码整洁带来的舒适感这些都不算什么
+ 个人app的编写
    + 业务流程
        + 注册
            + 用户注册时，会进行校验，如果用户名和邮箱重复将会拒绝注册，注册时会发送邮箱验证码防止用其他邮箱注册或者没有输入正确的邮箱格式
        + 日记编写
            + 正常日记
                + 点击相应日记编写就可以了，对匹配双方可视
            + 二类日记
                + 编写满足设置时间后对匹配的人可视，并且会与当前匹配匹配用户绑定，以后即使解除匹配也不会对其他人可视
        + 日记查询
            + 在时间线上展示所有编写的日记，可以切换到匹配用户的视图，也可以切换日记类型
        + 匹配
            + 不同用户可以通过邮箱进行匹配，匹配前会进行检测防止已经匹配的用户再次匹配
    + 项目结构
        + 前端
            + vue
            + vuetify
                + 时间线
                + 日历
        + 后端
            + springsecurity
        + 问题
            + UI组件在某些场合很方便，但是在细节的处理上比较麻烦，因为框架自己封装了一下方法和样式，导致有时候自己定义方法和样式不一定能生效，有种带着脚铐跳舞的感觉，强行上了springsecurity但是由于基础并不牢固，过滤器上并没有增加认证以外的其他功能，模块化也只是保留了形势，具体工程并没有体现模块化的思想。
        + 收获
            + 在学习vblog项目的过程中对于前后端的了解多了一些，比如对于接口请求方法的封装，url需要加密，比起上一个项目，这个项目中开始使用简单的es6语法了，也开始对UI框架中的组件进行二次封装满足自己项目的需求，比如全局提示信息组件，官方tip组件提供的demo只是点击触发写死的信息，但是我们需要的效果是根据不同的场景显示不同的信息，于是需要自己封装触发机制和结束机制，包括提示信息的传入等等，原本vblog中使用的是es5语法，经常看见var _this = this，一开始不知道是干什么的，后来自己看es6的过程中，知道了这个做法是为了将让方法内部找到this对象，而箭头函数解决了这个问题
            + 后端的接口设计比起上一个全post接口合理了很多，主要还是get和post接口，在下一个项目中将会完全遵循restful规范，初步使用springsecurity虽然的确繁琐，但是的确对项目很有帮助，尤其是在用户管理这一块，后端可以直接从security框架中获取当前用户的信息，减少了前端需要传入的参数，同时对于springboot的工作流程更加熟练了
            + 最后在实际部署服务时也碰到了很多问题，比如打包成apk之后，前端就不再有跨域的概念了，所以跨域请求会失效，需要修改请求方式，再比如实际场景下的调试问题，编程阶段可以选择断点或者输出，但是实际环境不可能允许断点调试的，输出成了唯一有效的方法，于是前端封装好的提示组件就成了很好的输出工具，还有app接口请求失败的结果，在浏览器调试和实际环境也是不一样的，浏览器会直接报错不返回数据，但是app会返回请求失败的数据，通过输出返回值才能知道app中实际发生了什么
            + 总体而言，积累了很多开发经验，但是逐渐感受到了弊端，几乎是一个人想产品，业务逻辑，想前端的渲染方式，后端接口构成和数据库组成等等，虽然很直观的感受到了什么时候调整前端还是接口或者查询语句可以最大程度的减少整体代码规模，但是要处理来自各个方面的问题反倒是让每个方面都没有深入下去，前几天回顾产品时感觉产品并没有什么亮点，虽然自己的确每个方面都在慢慢进步，但是过于缓慢，下面应该会选择一个方向深入下去。

+ 相关知识点整理
    + 